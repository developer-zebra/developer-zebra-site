---
title: Using EKD APIs
layout: guide.html
product: Enterprise Keyboard Designer
productversion: '1.0'
---

## Overview

Zebra Enterprise Keyboard APIs operate primarily through Android intents--specific commands that can be used by Android applications to control EKB. This guide describes the functionality of the intents supported by EKB and their effects on EKB layouts.
Requirements
The use of EKB APIs requires experience with Java programming and familiarity with Android Intents. It also requires knowledge of EKB usage, features and terminology. For more information about EKB, see the Enterprise Keyboard Techdocs at:
 http://techdocs.zebra.com/enterprise-keyboard

IMPORTANT USAGE NOTES - PLEASE READ
The Zebra Enterprise Keyboard MUST be installed on the device and selected as the default input source to make use of custom layouts created with EKD. 
Only one keyboard or custom key layout can be displayed on the device screen at a time. When a custom key layout is displayed, all other keyboards are hidden, including the alpha-numeric keyboard. 
Custom layouts must be called by an app using intents (see Appendix 1).
Multiple layouts can be saved in a single file, but only a single file can be accessed by apps on the device.  
EKD projects are automatically saved and deployed as encrypted files that can be decrypted only by DataWedge, Enterprise Browser and Enterprise Keyboard, applications running on a Zebra Android device, or by the Enterprise Keyboard Designer tool itself. 
Layout files can be imported into the Enterprise Keyboard Designer and modified or supplemented with additional keys or layouts. 
Zebra recommends resetting to the default input device when quitting an app that uses EKB. 
In this guide, the terms “button” and “key” are used interchangeably. 
 
Custom Keyboard Definition File
Custom keyboard layouts are created according to the business need by using , a desktop tool for Windows. The data for one or more layouts is stored in a custom keyboard definition file, an encrypted file generated by the Enterprise Keyboard Designer. This file contains information about layouts, key-value assignments, etc., for each keyboard layout. This single file also can contain multiple layout groups, each of which defines a layout.
To push a keyboard definition file:
Locate the custom keyboard definition file (i.e. “EKBCustomLayouts.encrypted”) that contains the desired layouts.
In the device Settings panel, set Enterprise Keyboard as a default IME.
Push definition file to the following folder on the device: 
/enterprise/device/settings/ekb/config/
 
IMPORTANT NOTES: 
Custom keyboard layouts are available to the app (via intents) immediately upon deployment of the “EKBCustomLayouts.encrypted”  file. 
Enterprise Keyboard must be installed on the device and set as the default input source to use custom layouts. 


Intents
App developers and administrators can use Android intents to determine programmatically which layouts are available in a device and to select and switch between layouts according to the input requirements of an application.

Sending Intents
The syntax defined in Enterprise Keyboard 2.0 permits multiple Enterprise Keyboard API calls as extras on a single intent action. The syntax is as follows:

	:::java
	Intent intent = new Intent();
	intent.setAction("com.symbol.ekb.api.ACTION_GET");
	intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
	intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
	String[]propertiesToRetrieve = {"AVAILABLE_LAYOUTS"};
	intent.putExtra("PROPERTIES_TO_GET", propertiesToRetrieve);

Receiving Results
For intents that query EKB for information (such as "GET_AVAILABLE_LAYOUTS"), the app must declare a receiver in the "AndroidManifest.xml" file and add a pending intent in the query intent as an extra to receive the result. 
The code below shows how to register the broadcast receiver to receive the results:

	:::java
	//Declare broadcast receiver in AndroidManifest.xml file
	<receiver android:name=".MyBroadcastReceiver"></receiver>

	//Sending intent to get available layouts
	Intent intent = new Intent();
	intent.setAction("com.symbol.ekb.api.ACTION_GET");
	intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
	intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
	String[] propertiesToRetrieve = {"AVAILABLE_LAYOUTS"};
	intent.putExtra("PROPERTIES_TO_GET", propertiesToRetrieve);


	//Intent sent back with status (via explicit broadcast)
	Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
	PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
	intent.putExtra("CALLBACK_RESPONSE", piResponse);
	sendBroadcast(intent);
	 
	//Receiving the result
	@Override
	public void onReceive(Context context, Intent intent) {
	    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
	    Bundle mBundle = intent.getExtras();
	    String result = mBundle.getString(“RESULT_CODE”);
	    String msg = mBundle.getString(“RESULT_MESSAGE”);
	}


Enterprise Keyboard APIs:
GET available keyboard layouts
GET current keyboard layout group & current keyboard layout name
SET keyboard layout
SHOW
ENABLE
RESET

Get available keyboard layouts
Returns a list of custom enterprise keyboard layouts currently available in the device.

Sample code to send the intent to get available keyboard layouts:

	:::java
		Intent intent = new Intent();
	intent.setAction("com.symbol.ekb.api.ACTION_GET");
		intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
	intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
	String[] propertiesToRetrieve = {"AVAILABLE_LAYOUTS};
	intent.putExtra("PROPERTIES_TO_GET", propertiesToRetrieve);

	//  Intent which will be sent back with status (via explicit broadcast)
	
	Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
	PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
	intent.putExtra("CALLBACK_RESPONSE", piResponse);
	sendBroadcast(intent);

Sample code to receive the result:

	:::java 
		@Override
	public void onReceive(Context context, Intent intent) {
	    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
	    Bundle mBundle = intent.getExtras();
	    String result = mBundle.getString("RESULT_CODE");
	    String msg = mBundle.getString("RESULT_MESSAGE");

	    if(mBundle.get("AVAILABLE_LAYOUTS") != null) {
	        Object[] respObj = (Object[]) mBundle.getParcelableArray("AVAILABLE_LAYOUTS");
	        for(int i = 0; i < respObj.length; i++) {
	            Bundle temp = (Bundle) respObj[i];
	            String layoutGroupName = temp.getString("LAYOUT_GROUP");
	            Object[] layoutNamesBundle = (Object[]) temp.get("LAYOUTS");
	            for(int j = 0; j <layoutNamesBundle.length; j++) {
	                Bundle tempBundle = (Bundle) layoutNamesBundle[j];
	                String layoutName = tempBundle.getString("LAYOUT_NAME");
	            }
	        }
	    }
	}


Get current keyboard layout group and current keyboard layout name
Returns the currently selected keyboard layout group and current keyboard layout name as set by Enterprise Keyboard.

Sample code to send the intent to get current keyboard layout group & current keyboard layout name:

	:::java
		Intent intent = new Intent();
	intent.setAction("com.symbol.ekb.api.ACTION_GET");
		intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
	intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
	String[] propertiesToRetrieve = {"CURRENT_LAYOUT_GROUP”,CURRENT_LAYOUT_NAME};
	intent.putExtra("PROPERTIES_TO_GET", propertiesToRetrieve);
	//  Intent which will be sent back with status (via explicit broadcast)
	Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
	PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
	intent.putExtra("CALLBACK_RESPONSE", piResponse);
	sendBroadcast(intent);

Sample code to receive the result:

	:::java
		@Override
	public void onReceive(Context context, Intent intent) {
	    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
	    Bundle mBundle = intent.getExtras();
	    String result = mBundle.getString("RESULT_CODE");
	    String msg = mBundle.getString("RESULT_MESSAGE");
	    if(mBundle.get("CURRENT_LAYOUT_GROUP") != null) {
	        String currLayoutGroup = (String) mBundle.get("CURRENT_LAYOUT_GROUP");
	    }
	    if(mBundle.get("CURRENT_LAYOUT_NAME") != null) {
	        String currLayoutName = (String) mBundle.get("CURRENT_LAYOUT_NAME");
	    }
	}


Set keyboard layout
Sets the custom layout in Enterprise Keyboard. While sending the intent to set the keyboard layout, developer must add "CURRENT_LAYOUT_GROUP” and  "CURRENT_LAYOUT_NAME" params as extras.

Once keyboard layout is set in Enterprise Keyboard, requested application receives a response intent having RESULT_CODE and RESULT_MESSAGE.

Sample code to set keyboard layout:

	:::java
		Intent intent = new Intent();
	intent.setAction("com.symbol.ekb.api.ACTION_UPDATE");
		intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
	intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
	String layoutGroupName = layoutGroup.getText().toString();
	String layout = layoutName.getText().toString();
	intent.putExtra("CURRENT_LAYOUT_GROUP", layoutGroupName);
	intent.putExtra("CURRENT_LAYOUT_NAME", layout);

	//  Intent which will be sent back with status (via explicit broadcast)
	Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
	PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
	intent.putExtra("CALLBACK_RESPONSE", piResponse);
	sendBroadcast(intent);
 

Sample code to receive the result:

	:::java
		@Override
	public void onReceive(Context context, Intent intent) {
	    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
	    Bundle mBundle = intent.getExtras();
	    String result = mBundle.getString("RESULT_CODE");
	    String msg = mBundle.getString("RESULT_MESSAGE");    
		}
	   
	}


ENABLE
Used to enable or disable the keyboard. This param has two states:
TRUE: Keyboard is enabled but not shown unless the device user taps on an input area.
FALSE: Keyboard is disabled and does not show even after using SHOW API or tapping on an input area.

Once keyboard is enabled/disabled, requested application will receive a response intent having RESULT_CODE and RESULT_MESSAGE.

Sample code to show keyboard:

	:::java
		Intent intent = new Intent();
	intent.setAction("com.symbol.ekb.api.ACTION_UPDATE");
		intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
	intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
	intent.putExtra("ENABLE", needToEnable);	// needToEnable is a Boolean object so it can be 
						//either true or false.

	//  Intent which will be sent back with status (via explicit broadcast)
	Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
	PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
	intent.putExtra("CALLBACK_RESPONSE", piResponse);
	sendBroadcast(intent);
	 

Sample code to receive the result:

	::java
		@Override
	public void onReceive(Context context, Intent intent) {
	    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
	    Bundle mBundle = intent.getExtras();
	    String result = mBundle.getString("RESULT_CODE");
	    String msg = mBundle.getString("RESULT_MESSAGE");    
	}


RESET
Resets the Enterprise Keyboard layouts and enables the keyboard if it is disabled. After reset, user will be shown fixed layout Enterprise Keyboard. 

It has two states:
TRUE: Keyboard is reset.
FALSE: Keyboard is not reset.

Requested application receives a response intent with RESULT_CODE and RESULT_MESSAGE.

Sample code to show keyboard:

	:::java
		Intent intent = new Intent();
	intent.setAction("com.symbol.ekb.api.ACTION_DO");
		intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
	intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
	intent.putExtra("RESET_LAYOUT", needToReset);	// needToReset is a Boolean object so it
							// can be either true or false.

	//Intent sent back with status (via explicit broadcast)
	Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
	PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
	intent.putExtra("CALLBACK_RESPONSE", piResponse);
	sendBroadcast(intent);

Sample code to receive the result:

	:::java
		@Override
	public void onReceive(Context context, Intent intent) {
	    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
	    Bundle mBundle = intent.getExtras();
	    String result = mBundle.getString("RESULT_CODE");
	    String msg = mBundle.getString("RESULT_MESSAGE");    
	}


Limitations
If the application contains logic to show the keyboard automatically when an activity comes to the foreground (i.e. activity has a declared flag "android:windowSoftInputMode="stateVisible" in its AndroidManifest.xml file), the app cannot hide the keyboard using the SHOW API.

If the app is running in full screen mode, the custom keyboard layout displays with an extra margin from the bottom of the device.

A layout group can contain more than one layout; Enterprise Keyboard currently supports only one layout group.
 
 
App Design Using EKB Intent APIs
The following example describes a company with business requirements that call for an application with four GUI screens: 

FunctionKeyActivity
DisableActivity
MultiInputActivity
ResetActivity 

FunctionKeyActivity is the launcher activity of the application, and is the first activity in the following sequence of the activities:

FunctionKeyActivity -> DisableActivity -> MultiInputActivity -> ResetActivity

Each activity involves the following keyboard requirements:

When FunctionKeyActivity comes in foreground, the app should GET the following information:
Available layouts in the device
Current layout group name
Current layout name

FunctionKeyActivity should then set a function-key keyboard layout to show immediately when the app it comes in the foreground.

DisableActivity does not use a keyboard, so keyboard should be disabled when this activity comes to the foreground. If the device user taps on an input area, a keyboard should not appear.

MultiInputActivity has two input areas. When the device user taps on the first input area, a qwerty keyboard layout appears. When the user taps on the second input area, the numeric keyboard layout appears.

ResetActivity uses a regular keyboard, so keyboard should be reset.


Note: Zebra provides a sample Android app that implements the functions described above.